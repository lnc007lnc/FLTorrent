syntax = "proto3";

service gRPCComServeFunc {
    // ğŸš€ åŸæœ‰çš„Unary RPC (å…¼å®¹æ€§)
    rpc sendMessage (MessageRequest) returns (MessageResponse) {};
    
    // ğŸš€ æ–°å¢ï¼šåŒå‘æµå¼RPCç”¨äºchunkä¼ è¾“
    rpc streamChunks (stream ChunkStreamRequest) returns (stream ChunkStreamResponse) {};
    
    // ğŸš€ æ–°å¢ï¼šæœåŠ¡ç«¯æµå¼RPCç”¨äºæ‰¹é‡chunkä¸‹è½½
    rpc downloadChunks (ChunkBatchRequest) returns (stream ChunkStreamResponse) {};
    
    // ğŸš€ æ–°å¢ï¼šå®¢æˆ·ç«¯æµå¼RPCç”¨äºæ‰¹é‡chunkä¸Šä¼   
    rpc uploadChunks (stream ChunkStreamRequest) returns (ChunkBatchResponse) {};
}

message MessageRequest{
    map<string, MsgValue> msg = 1;
}

message MsgValue{
    oneof type {
        mSingle single_msg = 1;
        mList list_msg = 2;
        mDict_keyIsString dict_msg_stringkey = 3;
        mDict_keyIsInt dict_msg_intkey = 4;
    }
}

message mSingle{
    oneof type {
        float float_value = 1;
        int32 int_value = 2;
        string str_value = 3;
        bytes bytes_value = 4;  // ğŸš€ Add bytes support for chunk data
    }
}

message mList{
    repeated MsgValue list_value = 1;
}

message mDict_keyIsString{
    map<string, MsgValue> dict_value = 1;
}

message mDict_keyIsInt{
    map<int32, MsgValue> dict_value = 1;
}

message MessageResponse{
    string msg = 1;
}

// ğŸš€ Streaming chunk messages for optimized BitTorrent transfer
message ChunkStreamRequest {
    int32 sender_id = 1;
    int32 receiver_id = 2;  
    int32 round_num = 3;
    int32 source_client_id = 4;
    int32 chunk_id = 5;
    bytes chunk_data = 6;        // ç›´æ¥bytesï¼Œæ— é¢å¤–åºåˆ—åŒ–
    string checksum = 7;
    int64 timestamp = 8;
    ChunkType chunk_type = 9;    // chunkç±»å‹ï¼šREQUEST/PIECE/HAVE/CANCEL
    float importance_score = 10; // chunké‡è¦æ€§è¯„åˆ†
}

message ChunkStreamResponse {
    int32 sender_id = 1;
    int32 receiver_id = 2;
    bool success = 3;
    string error_message = 4;
    int32 round_num = 5;
    int32 chunk_id = 6;
    ChunkResponseType response_type = 7; // ACK/NACK/HAVE/INTERESTED
    bytes response_data = 8;     // å¯é€‰ï¼šå“åº”æ•°æ®
}

message ChunkBatchRequest {
    int32 client_id = 1;
    int32 sender_id = 2;
    int32 round_num = 3;
    repeated ChunkRequest chunk_requests = 4;
}

message ChunkRequest {
    int32 source_client_id = 1;
    int32 chunk_id = 2;
    float importance_score = 3;
}

message ChunkBatchResponse {
    int32 client_id = 1;
    int32 successful_chunks = 2;
    int32 failed_chunks = 3;
    repeated string error_messages = 4;
}

enum ChunkType {
    CHUNK_REQUEST = 0;    // è¯·æ±‚chunk
    CHUNK_PIECE = 1;      // chunkæ•°æ®
    CHUNK_HAVE = 2;       // æ‹¥æœ‰é€šçŸ¥
    CHUNK_CANCEL = 3;     // å–æ¶ˆè¯·æ±‚
    CHUNK_BITFIELD = 4;   // bitfieldæ›´æ–°
    // ğŸ”§ æ–°å¢ï¼šBitTorrentåè®®æ§åˆ¶æ¶ˆæ¯ç±»å‹
    CHUNK_INTERESTED_REQ = 5; // è¡¨ç¤ºå¯¹peeræ„Ÿå…´è¶£
    CHUNK_UNCHOKE_REQ = 6;    // å…è®¸ä¸‹è½½
    CHUNK_CHOKE_REQ = 7;      // ç¦æ­¢ä¸‹è½½
}

enum ChunkResponseType {
    CHUNK_ACK = 0;        // ç¡®è®¤æ”¶åˆ°
    CHUNK_NACK = 1;       // æ‹’ç»/é”™è¯¯
    CHUNK_HAVE_RESP = 2;  // haveå“åº”
    CHUNK_INTERESTED_RESP = 3; // æ„Ÿå…´è¶£å“åº”
}
