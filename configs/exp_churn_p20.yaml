# Experiment 2: Churn Injection 20% with timeout+backfill+comp
# Purpose: Show robustness vs wait-for-all

use_gpu: True
device: 0
seed: 42

federate:
  mode: 'standalone'
  client_num: 50
  total_round_num: 100
  sample_client_num: 50
  method: FedAvg

data:
  root: 'data/'
  type: 'CIFAR10@torchvision'
  splits: [0.8, 0.1, 0.1]
  splitter: 'lda'
  splitter_args: [{'alpha': 0.5}]

dataloader:
  batch_size: 32

model:
  type: convnet2
  hidden: 512
  out_channels: 10
  dropout: 0.0

train:
  local_update_steps: 5
  batch_or_epoch: epoch
  optimizer:
    lr: 0.01
    type: SGD

criterion:
  type: CrossEntropyLoss

trainer:
  type: cvtrainer

eval:
  freq: 1
  metrics: ['acc', 'correct']
  report: ['weighted_avg', 'avg', 'raw']

# BitTorrent with churn injection
bittorrent:
  enable: true
  timeout: 60.0
  enable_compensation: true
  churn_injection: true
  churn_rate: 0.2  # 20% failure rate
  churn_mode: 'silent'
  save_statistics: true
  verbose: true
  log_dir: 'exp_out/churn_p20/bt_logs'

chunk:
  num_chunks: 16
  importance_method: 'magnitude'

outdir: 'exp_out/churn_p20'
