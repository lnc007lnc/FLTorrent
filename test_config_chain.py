#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Test BitTorrent configuration parameter chain
Verify complete chain: run_ray.py -> YAML config -> FederatedScope config -> BitTorrentManager
"""

import yaml
import sys
import os

# Add FederatedScope to path
sys.path.append('/oracle-data/dtg/Naicheng_Li/FLTorrent')

def test_config_chain():
    """Test config parameter chain"""
    print("üîç Testing BitTorrent config parameter chain...")
    
    # 1. Simulate CONFIG parameters from run_ray.py
    from run_ray import CONFIG
    print(f"‚úÖ Step 1: run_ray.py CONFIG parameters")
    print(f"   BT_MAX_ACTIVE_REQUESTS = {CONFIG.BT_MAX_ACTIVE_REQUESTS}")
    print(f"   BT_MAX_PENDING_QUEUE = {CONFIG.BT_MAX_PENDING_QUEUE}")
    print(f"   BT_MAX_UPLOAD_SLOTS = {CONFIG.BT_MAX_UPLOAD_SLOTS}")
    print()
    
    # 2. Simulate configuration generated by generate_base_config()
    config_dict = {
        'bittorrent': {
            'enable': True,
            'timeout': CONFIG.BITTORRENT_TIMEOUT,
            'verbose': True,
            'chunk_selection': CONFIG.BT_CHUNK_SELECTION,
            'min_completion_ratio': CONFIG.BT_MIN_COMPLETION_RATIO,
            'max_active_requests': CONFIG.BT_MAX_ACTIVE_REQUESTS,
            'max_pending_queue': CONFIG.BT_MAX_PENDING_QUEUE,
            'max_upload_slots': CONFIG.BT_MAX_UPLOAD_SLOTS
        }
    }
    print(f"‚úÖ Step 2: Generated configuration dictionary")
    print(f"   max_active_requests = {config_dict['bittorrent']['max_active_requests']}")
    print(f"   max_pending_queue = {config_dict['bittorrent']['max_pending_queue']}")
    print(f"   max_upload_slots = {config_dict['bittorrent']['max_upload_slots']}")
    print()
    
    # 3. Save as YAML and reload (simulate Docker configuration file transfer)
    yaml_content = yaml.safe_dump(config_dict)
    print(f"‚úÖ Step 3: YAML serialization content")
    print("   BitTorrent related lines:")
    for line in yaml_content.split('\n'):
        if 'max_active_requests' in line or 'max_pending_queue' in line or 'max_upload_slots' in line:
            print(f"     {line}")
    print()
    
    # Reload YAML
    reloaded_config = yaml.safe_load(yaml_content)
    print(f"‚úÖ Step 4: YAML deserialization verification")
    bt_config = reloaded_config['bittorrent']
    print(f"   max_active_requests = {bt_config['max_active_requests']}")
    print(f"   max_pending_queue = {bt_config['max_pending_queue']}")
    print(f"   max_upload_slots = {bt_config['max_upload_slots']}")
    print()
    
    # 4. Test FederatedScope configuration system
    try:
        from federatedscope.core.configs.config import global_cfg
        
        print(f"‚úÖ Step 5: FederatedScope configuration system test")
        
        # Get global configuration
        cfg = global_cfg.clone()
        
        # Check default values
        print(f"   Default max_active_requests = {cfg.bittorrent.max_active_requests}")
        print(f"   Default max_pending_queue = {cfg.bittorrent.max_pending_queue}")
        print(f"   Default max_upload_slots = {cfg.bittorrent.max_upload_slots}")
        
        # Simulate updating from YAML configuration
        cfg.merge_from_other_cfg(cfg)
        cfg.bittorrent.max_active_requests = bt_config['max_active_requests']
        cfg.bittorrent.max_pending_queue = bt_config['max_pending_queue']  
        cfg.bittorrent.max_upload_slots = bt_config['max_upload_slots']
        
        print(f"   Updated max_active_requests = {cfg.bittorrent.max_active_requests}")
        print(f"   Updated max_pending_queue = {cfg.bittorrent.max_pending_queue}")
        print(f"   Updated max_upload_slots = {cfg.bittorrent.max_upload_slots}")
        print()
        
        # 5. Test BitTorrentManager initialization
        from federatedscope.core.bittorrent_manager import BitTorrentManager
        
        print(f"‚úÖ Step 6: BitTorrentManager initialization test")
        
        # Create mock dependency objects
        class MockChunkManager:
            def get_global_bitfield(self, round_num):
                return {}
                
        class MockCommManager:
            def send(self, message):
                pass
        
        # Initialize BitTorrentManager
        bt_manager = BitTorrentManager(
            client_id=1,
            round_num=1,
            chunk_manager=MockChunkManager(),
            comm_manager=MockCommManager(),
            neighbors=[2, 3],
            cfg=cfg  # Pass configuration
        )
        
        print(f"   BitTorrentManager.MAX_ACTIVE_REQUESTS = {bt_manager.MAX_ACTIVE_REQUESTS}")
        print(f"   BitTorrentManager.MAX_PENDING_QUEUE = {bt_manager.MAX_PENDING_QUEUE}")
        print(f"   BitTorrentManager.MAX_UPLOAD_SLOTS = {bt_manager.MAX_UPLOAD_SLOTS}")
        print()
        
        # Verify if values are correctly passed
        if (bt_manager.MAX_ACTIVE_REQUESTS == CONFIG.BT_MAX_ACTIVE_REQUESTS and
            bt_manager.MAX_PENDING_QUEUE == CONFIG.BT_MAX_PENDING_QUEUE and
            bt_manager.MAX_UPLOAD_SLOTS == CONFIG.BT_MAX_UPLOAD_SLOTS):
            print("üéâ Configuration passing chain verification successful!")
            print("   run_ray.py -> YAML -> FederatedScope -> BitTorrentManager full chain operational")
            return True
        else:
            print("‚ùå Configuration passing chain verification failed!")
            print(f"   Expected: {CONFIG.BT_MAX_ACTIVE_REQUESTS}, {CONFIG.BT_MAX_PENDING_QUEUE}, {CONFIG.BT_MAX_UPLOAD_SLOTS}")
            print(f"   Actual: {bt_manager.MAX_ACTIVE_REQUESTS}, {bt_manager.MAX_PENDING_QUEUE}, {bt_manager.MAX_UPLOAD_SLOTS}")
            return False
            
    except Exception as e:
        print(f"‚ùå Step 5-6: FederatedScope configuration system test failed: {e}")
        import traceback
        traceback.print_exc()
        return False

if __name__ == "__main__":
    success = test_config_chain()
    sys.exit(0 if success else 1)